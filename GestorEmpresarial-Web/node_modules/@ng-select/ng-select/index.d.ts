import * as rxjs from 'rxjs';
import { Subject } from 'rxjs';
import * as _angular_core from '@angular/core';
import { ElementRef, OnDestroy, OnChanges, OnInit, AfterViewInit, TemplateRef, SimpleChanges, InjectionToken } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';

declare class NgSelectConfig {
    placeholder: string;
    fixedPlaceholder: boolean;
    notFoundText: string;
    typeToSearchText: string;
    addTagText: string;
    loadingText: string;
    clearAllText: string;
    disableVirtualScroll: boolean;
    openOnEnter: boolean;
    appendTo: string;
    bindValue: string;
    bindLabel: string;
    appearance: string;
    clearSearchOnAdd: boolean;
    deselectOnClick: boolean;
    tabFocusOnClear: boolean;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgSelectConfig, never>;
    static ɵprov: _angular_core.ɵɵInjectableDeclaration<NgSelectConfig>;
}

interface NgOption {
    [name: string]: any;
    index?: number;
    htmlId?: string;
    selected?: boolean;
    disabled?: boolean;
    marked?: boolean;
    label?: string;
    value?: string | any;
    parent?: NgOption;
    children?: NgOption[];
}
type DropdownPosition = 'top' | 'right' | 'bottom' | 'left' | 'auto';

type SelectionModelFactory = () => SelectionModel;
declare function DefaultSelectionModelFactory(): DefaultSelectionModel;
interface SelectionModel {
    value: NgOption[];
    select(item: NgOption, multiple: boolean, selectableGroupAsModel: boolean): any;
    unselect(item: NgOption, multiple: boolean): any;
    clear(keepDisabled: boolean): any;
}
declare class DefaultSelectionModel implements SelectionModel {
    private _selected;
    get value(): NgOption[];
    select(item: NgOption, multiple: boolean, groupAsModel: boolean): void;
    unselect(item: NgOption, multiple: boolean): void;
    clear(keepDisabled: boolean): void;
    private _setChildrenSelectedState;
    private _removeChildren;
    private _removeParent;
    private _activeChildren;
}

declare class ItemsList {
    private _ngSelect;
    private _selectionModel;
    private _groups;
    constructor(_ngSelect: NgSelectComponent, _selectionModel: SelectionModel);
    private _items;
    get items(): NgOption[];
    private _filteredItems;
    get filteredItems(): NgOption[];
    private _markedIndex;
    get markedIndex(): number;
    get selectedItems(): NgOption[];
    get markedItem(): NgOption;
    get noItemsToSelect(): boolean;
    get maxItemsSelected(): boolean;
    get lastSelectedItem(): NgOption;
    setItems(items: readonly any[]): void;
    select(item: NgOption): void;
    unselect(item: NgOption): void;
    findItem(value: any): NgOption;
    addItem(item: any): NgOption;
    clearSelected(keepDisabled?: boolean): void;
    findByLabel(term: string): NgOption;
    filter(term: string): void;
    resetFilteredItems(): void;
    unmarkItem(): void;
    markNextItem(): void;
    markPreviousItem(): void;
    markItem(item: NgOption): void;
    markSelectedOrDefault(markDefault?: boolean): void;
    resolveNested(option: any, key: string): any;
    mapItem(item: any, index: number): NgOption;
    mapSelectedItems(): void;
    private _showSelected;
    private _hideSelected;
    private _defaultSearchFn;
    private _getNextItemIndex;
    private _stepToItem;
    private _getLastMarkedIndex;
    private _groupBy;
    private _flatten;
}

type StateChange = {
    value: any;
    disabled: boolean;
    label?: string;
};
declare class NgOptionComponent {
    readonly value: _angular_core.InputSignal<any>;
    readonly disabled: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly elementRef: ElementRef<any>;
    readonly label: _angular_core.WritableSignal<string>;
    constructor();
    readonly stateChange: _angular_core.Signal<StateChange>;
    readonly stateChange$: rxjs.Observable<StateChange>;
    private get _label();
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgOptionComponent, never>;
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<NgOptionComponent, "ng-option", never, { "value": { "alias": "value"; "required": false; "isSignal": true; }; "disabled": { "alias": "disabled"; "required": false; "isSignal": true; }; }, {}, never, ["*"], true, never>;
}

declare const SELECTION_MODEL_FACTORY: InjectionToken<SelectionModelFactory>;
type AddTagFn = (term: string) => any | Promise<any>;
type CompareWithFn = (a: any, b: any) => boolean;
type GroupValueFn = (key: string | any, children: any[]) => string | any;
declare class NgSelectComponent implements OnDestroy, OnChanges, OnInit, AfterViewInit, ControlValueAccessor {
    readonly classes: string;
    private readonly autoFocus;
    readonly config: NgSelectConfig;
    private readonly _cd;
    private readonly _console;
    readonly _disabled: _angular_core.WritableSignal<boolean>;
    readonly ariaLabelDropdown: _angular_core.InputSignal<string>;
    readonly ariaLabel: _angular_core.InputSignal<string>;
    readonly markFirst: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly placeholder: _angular_core.InputSignal<string>;
    readonly fixedPlaceholder: _angular_core.InputSignal<boolean>;
    readonly notFoundText: _angular_core.InputSignal<string>;
    readonly typeToSearchText: _angular_core.InputSignal<string>;
    readonly preventToggleOnRightClick: _angular_core.InputSignal<boolean>;
    readonly addTagText: _angular_core.InputSignal<string>;
    readonly loadingText: _angular_core.InputSignal<string>;
    readonly clearAllText: _angular_core.InputSignal<string>;
    readonly dropdownPosition: _angular_core.InputSignal<DropdownPosition>;
    readonly appendTo: _angular_core.InputSignal<string>;
    readonly loading: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly closeOnSelect: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly hideSelected: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly selectOnTab: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly openOnEnter: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly maxSelectedItems: _angular_core.InputSignalWithTransform<number, unknown>;
    readonly groupBy: _angular_core.InputSignal<string | ((value: any) => any)>;
    readonly groupValue: _angular_core.InputSignal<GroupValueFn>;
    readonly bufferAmount: _angular_core.InputSignalWithTransform<number, unknown>;
    readonly virtualScroll: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly selectableGroup: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly tabFocusOnClearButton: _angular_core.InputSignal<boolean>;
    readonly selectableGroupAsModel: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly searchFn: _angular_core.InputSignal<any>;
    readonly trackByFn: _angular_core.InputSignal<any>;
    readonly clearOnBackspace: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly labelForId: _angular_core.InputSignal<any>;
    readonly inputAttrs: _angular_core.InputSignal<{
        [key: string]: string;
    }>;
    readonly tabIndex: _angular_core.InputSignalWithTransform<number, unknown>;
    readonly readonly: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly searchWhileComposing: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly minTermLength: _angular_core.InputSignalWithTransform<number, unknown>;
    readonly editableSearchTerm: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly ngClass: _angular_core.InputSignal<any>;
    readonly typeahead: _angular_core.InputSignal<Subject<string>>;
    readonly multiple: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly addTag: _angular_core.InputSignal<boolean | AddTagFn>;
    readonly searchable: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly clearable: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly deselectOnClick: _angular_core.InputSignal<boolean>;
    readonly clearSearchOnAdd: _angular_core.InputSignal<any>;
    readonly compareWith: _angular_core.InputSignalWithTransform<CompareWithFn, CompareWithFn>;
    readonly bindLabel: _angular_core.ModelSignal<string>;
    readonly bindValue: _angular_core.ModelSignal<string>;
    readonly appearance: _angular_core.ModelSignal<string>;
    readonly isOpen: _angular_core.ModelSignal<boolean>;
    readonly items: _angular_core.ModelSignal<any[]>;
    readonly blurEvent: _angular_core.OutputEmitterRef<any>;
    readonly focusEvent: _angular_core.OutputEmitterRef<any>;
    readonly changeEvent: _angular_core.OutputEmitterRef<any>;
    readonly openEvent: _angular_core.OutputEmitterRef<void>;
    readonly closeEvent: _angular_core.OutputEmitterRef<void>;
    readonly searchEvent: _angular_core.OutputEmitterRef<{
        term: string;
        items: any[];
    }>;
    readonly clearEvent: _angular_core.OutputEmitterRef<void>;
    readonly addEvent: _angular_core.OutputEmitterRef<any>;
    readonly removeEvent: _angular_core.OutputEmitterRef<any>;
    readonly scroll: _angular_core.OutputEmitterRef<{
        start: number;
        end: number;
    }>;
    readonly scrollToEnd: _angular_core.OutputEmitterRef<any>;
    readonly disabled: _angular_core.Signal<boolean>;
    readonly clearSearchOnAddValue: _angular_core.Signal<any>;
    readonly deselectOnClickValue: _angular_core.Signal<boolean>;
    readonly optionTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly optgroupTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly labelTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly multiLabelTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly headerTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly footerTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly notFoundTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly placeholderTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly typeToSearchTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly loadingTextTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly tagTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly loadingSpinnerTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly clearButtonTemplate: _angular_core.Signal<TemplateRef<any>>;
    readonly dropdownPanel: _angular_core.Signal<any>;
    readonly searchInput: _angular_core.Signal<ElementRef<HTMLInputElement>>;
    readonly clearButton: _angular_core.Signal<ElementRef<HTMLSpanElement>>;
    ngOptions: _angular_core.Signal<readonly NgOptionComponent[]>;
    ngOptionsObservable: rxjs.Observable<readonly NgOptionComponent[]>;
    itemsList: ItemsList;
    viewPortItems: NgOption[];
    searchTerm: string;
    dropdownId: string;
    element: HTMLElement;
    focused: boolean;
    escapeHTML: boolean;
    tabFocusOnClear: _angular_core.WritableSignal<boolean>;
    private _itemsAreUsed;
    private readonly _defaultLabel;
    private _primitive;
    private _manualOpen;
    private _pressedKeys;
    private _isComposing;
    private readonly _destroy$;
    private readonly _keyPress$;
    constructor();
    get filtered(): boolean;
    get selectedItems(): NgOption[];
    get selectedValues(): any[];
    get hasValue(): boolean;
    get currentPanelPosition(): DropdownPosition;
    get showAddTag(): boolean;
    private get _editableSearchTerm();
    private get _isTypeahead();
    private get _validTerm();
    readonly keyDownFn: _angular_core.InputSignal<(_: KeyboardEvent) => boolean>;
    clearItem: (item: any) => void;
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    handleKeyDown($event: KeyboardEvent): void;
    handleKeyCode($event: KeyboardEvent): void;
    handleKeyCodeInput($event: KeyboardEvent): void;
    handleKeyCodeClear($event: KeyboardEvent): void;
    handleMousedown($event: MouseEvent): boolean;
    handleArrowClick(): void;
    handleClearClick(_event?: MouseEvent): void;
    clearModel(): void;
    writeValue(value: any | any[]): void;
    registerOnChange(fn: any): void;
    registerOnTouched(fn: any): void;
    setDisabledState(state: boolean): void;
    toggle(): void;
    open(): void;
    close(): void;
    toggleItem(item: NgOption): void;
    select(item: NgOption): void;
    focus(): void;
    blur(): void;
    unselect(item: NgOption): void;
    selectTag(): void;
    showClear(): boolean;
    focusOnClear(): void;
    trackByOption: (_: number, item: NgOption) => any;
    showNoItemsFound(): boolean;
    showTypeToSearch(): boolean;
    onCompositionStart(): void;
    onCompositionEnd(term: string): void;
    filter(term: string): void;
    onInputFocus($event: FocusEvent): void;
    onInputBlur($event: FocusEvent): void;
    onItemHover(item: NgOption): void;
    detectChanges(): void;
    private _onChange;
    private _onTouched;
    private _setSearchTermFromItems;
    private _setItems;
    private _setItemsFromNgOptions;
    private _isValidWriteValue;
    private _handleWriteValue;
    private _handleKeyPresses;
    private _setInputAttributes;
    private _setTabFocusOnClear;
    private _updateNgModel;
    private _clearSearch;
    private _changeSearch;
    private _scrollToMarked;
    private _scrollToTag;
    private _onSelectionChanged;
    private _handleTab;
    private _handleEnter;
    private _handleSpace;
    private _handleArrowDown;
    private _handleArrowUp;
    private _nextItemIsTag;
    private _handleBackspace;
    private _mergeGlobalConfig;
    /**
     * Gets virtual scroll value from input or from config
     *
     *  @param config NgSelectConfig object
     *
     *  @returns `true` if virtual scroll is enabled, `false` otherwise
     */
    private getVirtualScroll;
    /**
     * Gets disableVirtualScroll value from input or from config
     *
     *  @param config NgSelectConfig object
     *
     *  @returns `true` if disableVirtualScroll is enabled, `false` otherwise
     */
    private isVirtualScrollDisabled;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgSelectComponent, never>;
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<NgSelectComponent, "ng-select", never, { "ariaLabelDropdown": { "alias": "ariaLabelDropdown"; "required": false; "isSignal": true; }; "ariaLabel": { "alias": "ariaLabel"; "required": false; "isSignal": true; }; "markFirst": { "alias": "markFirst"; "required": false; "isSignal": true; }; "placeholder": { "alias": "placeholder"; "required": false; "isSignal": true; }; "fixedPlaceholder": { "alias": "fixedPlaceholder"; "required": false; "isSignal": true; }; "notFoundText": { "alias": "notFoundText"; "required": false; "isSignal": true; }; "typeToSearchText": { "alias": "typeToSearchText"; "required": false; "isSignal": true; }; "preventToggleOnRightClick": { "alias": "preventToggleOnRightClick"; "required": false; "isSignal": true; }; "addTagText": { "alias": "addTagText"; "required": false; "isSignal": true; }; "loadingText": { "alias": "loadingText"; "required": false; "isSignal": true; }; "clearAllText": { "alias": "clearAllText"; "required": false; "isSignal": true; }; "dropdownPosition": { "alias": "dropdownPosition"; "required": false; "isSignal": true; }; "appendTo": { "alias": "appendTo"; "required": false; "isSignal": true; }; "loading": { "alias": "loading"; "required": false; "isSignal": true; }; "closeOnSelect": { "alias": "closeOnSelect"; "required": false; "isSignal": true; }; "hideSelected": { "alias": "hideSelected"; "required": false; "isSignal": true; }; "selectOnTab": { "alias": "selectOnTab"; "required": false; "isSignal": true; }; "openOnEnter": { "alias": "openOnEnter"; "required": false; "isSignal": true; }; "maxSelectedItems": { "alias": "maxSelectedItems"; "required": false; "isSignal": true; }; "groupBy": { "alias": "groupBy"; "required": false; "isSignal": true; }; "groupValue": { "alias": "groupValue"; "required": false; "isSignal": true; }; "bufferAmount": { "alias": "bufferAmount"; "required": false; "isSignal": true; }; "virtualScroll": { "alias": "virtualScroll"; "required": false; "isSignal": true; }; "selectableGroup": { "alias": "selectableGroup"; "required": false; "isSignal": true; }; "tabFocusOnClearButton": { "alias": "tabFocusOnClearButton"; "required": false; "isSignal": true; }; "selectableGroupAsModel": { "alias": "selectableGroupAsModel"; "required": false; "isSignal": true; }; "searchFn": { "alias": "searchFn"; "required": false; "isSignal": true; }; "trackByFn": { "alias": "trackByFn"; "required": false; "isSignal": true; }; "clearOnBackspace": { "alias": "clearOnBackspace"; "required": false; "isSignal": true; }; "labelForId": { "alias": "labelForId"; "required": false; "isSignal": true; }; "inputAttrs": { "alias": "inputAttrs"; "required": false; "isSignal": true; }; "tabIndex": { "alias": "tabIndex"; "required": false; "isSignal": true; }; "readonly": { "alias": "readonly"; "required": false; "isSignal": true; }; "searchWhileComposing": { "alias": "searchWhileComposing"; "required": false; "isSignal": true; }; "minTermLength": { "alias": "minTermLength"; "required": false; "isSignal": true; }; "editableSearchTerm": { "alias": "editableSearchTerm"; "required": false; "isSignal": true; }; "ngClass": { "alias": "ngClass"; "required": false; "isSignal": true; }; "typeahead": { "alias": "typeahead"; "required": false; "isSignal": true; }; "multiple": { "alias": "multiple"; "required": false; "isSignal": true; }; "addTag": { "alias": "addTag"; "required": false; "isSignal": true; }; "searchable": { "alias": "searchable"; "required": false; "isSignal": true; }; "clearable": { "alias": "clearable"; "required": false; "isSignal": true; }; "deselectOnClick": { "alias": "deselectOnClick"; "required": false; "isSignal": true; }; "clearSearchOnAdd": { "alias": "clearSearchOnAdd"; "required": false; "isSignal": true; }; "compareWith": { "alias": "compareWith"; "required": false; "isSignal": true; }; "bindLabel": { "alias": "bindLabel"; "required": false; "isSignal": true; }; "bindValue": { "alias": "bindValue"; "required": false; "isSignal": true; }; "appearance": { "alias": "appearance"; "required": false; "isSignal": true; }; "isOpen": { "alias": "isOpen"; "required": false; "isSignal": true; }; "items": { "alias": "items"; "required": false; "isSignal": true; }; "keyDownFn": { "alias": "keyDownFn"; "required": false; "isSignal": true; }; }, { "bindLabel": "bindLabelChange"; "bindValue": "bindValueChange"; "appearance": "appearanceChange"; "isOpen": "isOpenChange"; "items": "itemsChange"; "blurEvent": "blur"; "focusEvent": "focus"; "changeEvent": "change"; "openEvent": "open"; "closeEvent": "close"; "searchEvent": "search"; "clearEvent": "clear"; "addEvent": "add"; "removeEvent": "remove"; "scroll": "scroll"; "scrollToEnd": "scrollToEnd"; }, ["optionTemplate", "optgroupTemplate", "labelTemplate", "multiLabelTemplate", "headerTemplate", "footerTemplate", "notFoundTemplate", "placeholderTemplate", "typeToSearchTemplate", "loadingTextTemplate", "tagTemplate", "loadingSpinnerTemplate", "clearButtonTemplate", "ngOptions"], never, true, never>;
}

declare class NgDropdownPanelComponent implements OnInit, OnChanges, OnDestroy {
    private _renderer;
    private _zone;
    private _panelService;
    private _document;
    private _dropdown;
    readonly items: _angular_core.InputSignal<NgOption[]>;
    readonly markedItem: _angular_core.InputSignal<NgOption>;
    readonly position: _angular_core.InputSignal<DropdownPosition>;
    readonly appendTo: _angular_core.InputSignal<string>;
    readonly bufferAmount: _angular_core.InputSignal<number>;
    readonly virtualScroll: _angular_core.InputSignalWithTransform<boolean, unknown>;
    readonly headerTemplate: _angular_core.InputSignal<TemplateRef<any>>;
    readonly footerTemplate: _angular_core.InputSignal<TemplateRef<any>>;
    readonly filterValue: _angular_core.InputSignal<string>;
    readonly ariaLabelDropdown: _angular_core.InputSignal<string>;
    readonly update: _angular_core.OutputEmitterRef<any[]>;
    readonly scroll: _angular_core.OutputEmitterRef<{
        start: number;
        end: number;
    }>;
    readonly scrollToEnd: _angular_core.OutputEmitterRef<void>;
    readonly outsideClick: _angular_core.OutputEmitterRef<void>;
    private readonly contentElementRef;
    private readonly scrollElementRef;
    private readonly paddingElementRef;
    private readonly _destroy$;
    private readonly _virtualPadding;
    private readonly _scrollablePanel;
    private readonly _contentPanel;
    private _select;
    private _parent;
    private _scrollToEndFired;
    private _updateScrollHeight;
    private _lastScrollPosition;
    private _currentPosition;
    get currentPosition(): DropdownPosition;
    private _itemsLength;
    private get itemsLength();
    private set itemsLength(value);
    private get _startOffset();
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    scrollTo(option: NgOption, startFromOption?: boolean): void;
    scrollToTag(): void;
    adjustPosition(): void;
    private _handleDropdownPosition;
    private _updateDropdownClass;
    private _handleScroll;
    private _handleOutsideClick;
    private _checkToClose;
    private _onItemsChange;
    private _updateItems;
    private _updateItemsRange;
    private _onContentScrolled;
    private _updateVirtualHeight;
    private _setVirtualHeight;
    private _onItemsLengthChanged;
    private _renderItemsRange;
    private _measureDimensions;
    private _fireScrollToEnd;
    private _calculateCurrentPosition;
    private _appendDropdown;
    private _updateXPosition;
    private _updateYPosition;
    private _setupMousedownListener;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgDropdownPanelComponent, never>;
    static ɵcmp: _angular_core.ɵɵComponentDeclaration<NgDropdownPanelComponent, "ng-dropdown-panel", never, { "items": { "alias": "items"; "required": false; "isSignal": true; }; "markedItem": { "alias": "markedItem"; "required": false; "isSignal": true; }; "position": { "alias": "position"; "required": false; "isSignal": true; }; "appendTo": { "alias": "appendTo"; "required": false; "isSignal": true; }; "bufferAmount": { "alias": "bufferAmount"; "required": false; "isSignal": true; }; "virtualScroll": { "alias": "virtualScroll"; "required": false; "isSignal": true; }; "headerTemplate": { "alias": "headerTemplate"; "required": false; "isSignal": true; }; "footerTemplate": { "alias": "footerTemplate"; "required": false; "isSignal": true; }; "filterValue": { "alias": "filterValue"; "required": false; "isSignal": true; }; "ariaLabelDropdown": { "alias": "ariaLabelDropdown"; "required": false; "isSignal": true; }; }, { "update": "update"; "scroll": "scroll"; "scrollToEnd": "scrollToEnd"; "outsideClick": "outsideClick"; }, never, ["*"], true, never>;
}

declare class NgItemLabelDirective {
    private element;
    ngItemLabel: _angular_core.InputSignal<string>;
    escape: _angular_core.InputSignal<boolean>;
    constructor();
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgItemLabelDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgItemLabelDirective, "[ngItemLabel]", never, { "ngItemLabel": { "alias": "ngItemLabel"; "required": false; "isSignal": true; }; "escape": { "alias": "escape"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}
declare class NgOptionTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgOptionTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgOptionTemplateDirective, "[ng-option-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgOptgroupTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgOptgroupTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgOptgroupTemplateDirective, "[ng-optgroup-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgLabelTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgLabelTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgLabelTemplateDirective, "[ng-label-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgMultiLabelTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgMultiLabelTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgMultiLabelTemplateDirective, "[ng-multi-label-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgHeaderTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgHeaderTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgHeaderTemplateDirective, "[ng-header-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgFooterTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgFooterTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgFooterTemplateDirective, "[ng-footer-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgNotFoundTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgNotFoundTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgNotFoundTemplateDirective, "[ng-notfound-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgPlaceholderTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgPlaceholderTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgPlaceholderTemplateDirective, "[ng-placeholder-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgTypeToSearchTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgTypeToSearchTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgTypeToSearchTemplateDirective, "[ng-typetosearch-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgLoadingTextTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgLoadingTextTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgLoadingTextTemplateDirective, "[ng-loadingtext-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgTagTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgTagTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgTagTemplateDirective, "[ng-tag-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgLoadingSpinnerTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgLoadingSpinnerTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgLoadingSpinnerTemplateDirective, "[ng-loadingspinner-tmp]", never, {}, {}, never, never, true, never>;
}
declare class NgClearButtonTemplateDirective {
    readonly template: TemplateRef<any>;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgClearButtonTemplateDirective, never>;
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<NgClearButtonTemplateDirective, "[ng-clearbutton-tmp]", never, {}, {}, never, never, true, never>;
}

declare class NgSelectModule {
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgSelectModule, never>;
    static ɵmod: _angular_core.ɵɵNgModuleDeclaration<NgSelectModule, never, [typeof NgDropdownPanelComponent, typeof NgOptionComponent, typeof NgSelectComponent, typeof NgOptgroupTemplateDirective, typeof NgOptionTemplateDirective, typeof NgLabelTemplateDirective, typeof NgMultiLabelTemplateDirective, typeof NgHeaderTemplateDirective, typeof NgFooterTemplateDirective, typeof NgPlaceholderTemplateDirective, typeof NgClearButtonTemplateDirective, typeof NgNotFoundTemplateDirective, typeof NgTypeToSearchTemplateDirective, typeof NgLoadingTextTemplateDirective, typeof NgTagTemplateDirective, typeof NgLoadingSpinnerTemplateDirective, typeof NgItemLabelDirective], [typeof NgSelectComponent, typeof NgOptionComponent, typeof NgOptgroupTemplateDirective, typeof NgOptionTemplateDirective, typeof NgLabelTemplateDirective, typeof NgMultiLabelTemplateDirective, typeof NgHeaderTemplateDirective, typeof NgFooterTemplateDirective, typeof NgPlaceholderTemplateDirective, typeof NgNotFoundTemplateDirective, typeof NgTypeToSearchTemplateDirective, typeof NgLoadingTextTemplateDirective, typeof NgTagTemplateDirective, typeof NgLoadingSpinnerTemplateDirective, typeof NgClearButtonTemplateDirective]>;
    static ɵinj: _angular_core.ɵɵInjectorDeclaration<NgSelectModule>;
}

declare class ConsoleService {
    warn(message: string): void;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<ConsoleService, never>;
    static ɵprov: _angular_core.ɵɵInjectableDeclaration<ConsoleService>;
}

interface ItemsRangeResult {
    scrollHeight: number;
    topPadding: number;
    start: number;
    end: number;
}
interface PanelDimensions {
    itemHeight: number;
    panelHeight: number;
    itemsPerViewport: number;
}
declare class NgDropdownPanelService {
    private _dimensions;
    get dimensions(): PanelDimensions;
    calculateItems(scrollPos: number, itemsLength: number, buffer: number): ItemsRangeResult;
    setDimensions(itemHeight: number, panelHeight: number): void;
    getScrollTo(itemTop: number, itemHeight: number, lastScroll: number): number;
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<NgDropdownPanelService, never>;
    static ɵprov: _angular_core.ɵɵInjectableDeclaration<NgDropdownPanelService>;
}

export { ConsoleService, DefaultSelectionModel, DefaultSelectionModelFactory, NgClearButtonTemplateDirective, NgDropdownPanelComponent, NgDropdownPanelService, NgFooterTemplateDirective, NgHeaderTemplateDirective, NgItemLabelDirective, NgLabelTemplateDirective, NgLoadingSpinnerTemplateDirective, NgLoadingTextTemplateDirective, NgMultiLabelTemplateDirective, NgNotFoundTemplateDirective, NgOptgroupTemplateDirective, NgOptionComponent, NgOptionTemplateDirective, NgPlaceholderTemplateDirective, NgSelectComponent, NgSelectConfig, NgSelectModule, NgTagTemplateDirective, NgTypeToSearchTemplateDirective, SELECTION_MODEL_FACTORY };
export type { DropdownPosition, NgOption, SelectionModel };
